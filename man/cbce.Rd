% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cbce.R
\name{cbce}
\alias{cbce}
\title{Correlation Bi-community Extraction method}
\usage{
cbce(X, Y, alpha = 0.05, alpha.init = alpha,
  cache.size = (utils::object.size(X) + utils::object.size(Y))/2,
  start_nodes = NULL, max_iterations = 20,
  interaction = interaction_none, diagnostic = diagnostics)
}
\arguments{
\item{X, Y}{Numeric Matices. Represents the two groups of variables.}

\item{alpha}{\eqn{\in (0,1)}. Controls the type1 error per update. This is the type1 error to use for multiple_testing procedure}

\item{alpha.init}{\eqn{\in (0,1)} Controls the type1 error for the initialization step. This should perhaps be more lax than alpha.}

\item{cache.size}{The amount of memory to dedicate for caching correlations. This will speed things up. Defaults to the average memory required by X and Y matrices}

\item{start_nodes}{The initial set of nodes to start with. If Null start from all the nodes.}

\item{max_iterations}{The maximum number of iterations per extraction. If a fixed point is not found by this step, the extraciton is terminated.}

\item{interaction}{This is a function that will be called between extracts to allow interaction with the program. For instance one cas pass interaction_gui (EXPERIMENTAL!) or interaction_none.}

\item{diagnostic}{This is a function for probing the internal state of the method. It will be called at "Events" and can look into what the method is doing. Pass either diagnostics2, diagnostics_none or a custom function.}
}
\value{
The return value is a list with details of the extraction and list of indices representing the communities. See example below (finding communities in noise). Note that the variables from the X and Y set are denoted using a single numbering. Hence the nodes in X are denoted by \code{1:dx} and the nodes in Y are denoted by the numbers following dx (hence \code{dx+1:dy})
}
\description{
Given two groups of variables, find correlation bi-communities between them. For such a community, the nodes from the first group are are higly correlated to the community-nodes from the second group, and vice versa.
}
\details{
\code{cbce} applies an update function (mapping subsets of variables to subsets of variables) iteratively until a fixed point is found. These fixed points are reported as communities. The update function uses multiple-testing procedure to find variables correlated to the current set of variables.

The update starts from a single node (starting with the initialization step) and is repeated till either a fixed point is found or some set repeats. Each such run is called an extraction. Since the extraction only starts from singleton node, there are \code{ncol(X)+ncol(Y)} possible extractions.
}
\examples{
\dontrun{
n <- 100
dx <- 50
dy <- 70

X <- matrix(rnorm(n*dx), ncol=dx)
Y <- matrix(rnorm(n*dy), ncol=dy)
res <- cbce2(X, Y)
df <- res$filtered_result.df
# The filtered bimodules:
bms <- rlist::list.map(res$extract_res[df$index], bimod)
}
}
